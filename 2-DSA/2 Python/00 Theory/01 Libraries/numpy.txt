
NumPy : For numerical (mathematical & statistical) Computation

1. Common functions : 
    - Mathematics : np.sum, np.exp, np.round, etc arithmetic operators
    - Array Manipulation : np.reshape, np.stack, np.concatenate, np.split
    - Linear Algebra : np.matmul, np.dot, np.transpose, np.eigvals
    - Statistics : np.mean, np.median, np.std, np.max

    The array object in NumPy is called ndarray, it provides a lot of supporting functions that make working with ndarray very easy.

2. Why is NumPy Faster Than Lists? 
    - NumPy aims to provide an array object that is up to 50x faster than traditional Python lists.
    - NumPy arrays are stored at one continuous place in memory unlike lists, so processes can access and manipulate them very efficiently.
    - This behavior is called locality of reference in computer science.
    - This is the main reason why NumPy is faster than lists. Also it is optimized to work with latest CPU architectures.

3. Which Language is NumPy written in?
    - NumPy is a Python library and is written partially in Python, but most of the parts that require fast computation are written in C or C++.

4. ndim : NumPy Arrays provides the ndim attribute that returns an integer that tells us how many dimensions the array have.
    e.g. print(a.ndim)
5. ndmin : When the array is created, you can define the number of dimensions by using the ndmin argument.
    e.g. import numpy as np
    arr = np.array([1, 2, 3, 4], ndmin=5)

6. Data Types in Python : By default Python have these data types:
        strings - for text data, the text is given under quote marks. e.g. "ABCD"
        integer - integer numbers. e.g. -1, -2, -3, 0, 1
        float - for real numbers. e.g. 1.2, 42.42
        boolean - for True or False.
        complex - for complex numbers. e.g. 1.0 + 2.0j, 1.5 + 2.5j

    Data Types in NumPy : NumPy has some extra data types, and refer to data types with one character, like i for integers, u for unsigned integers etc.
        i - integer
        b - boolean
        u - unsigned integer
        f - float
        c - complex float
        m - timedelta
        M - datetime
        O - object
        S - string
        U - unicode string
        V - fixed chunk of memory for other type ( void )

    - dtype : dtype that returns the data type of the array
        e.g. arr = np.array([1, 2, 3, 4])
             print(arr.dtype)
    - Creating Arrays With a Defined Data Type : 
        arr = np.array([1, 2, 3, 4], dtype='S')
        arr = np.array([1, 2, 3, 4], dtype='i4')   # For i, u, f, S and U we can define size as well.

    - astype() : Converting Data Type on Existing Arrays
        e.g. arr = np.array([1.1, 2.1, 3.1])
             newarr = arr.astype('i')
             newarr = arr.astype(int)   # full name also allowed

7. Copy and View
    - The main difference between a copy and a view of an array is that the copy is a new array, and the view is just a view of the original array.
    - The copy owns the data and any changes made to the copy will not affect original array, and any changes made to the original array will not affect the copy.
    - The view does not own the data and any changes made to the view will affect the original array, and any changes made to the original array will affect the view.

    - e.g. 
    import numpy as np
        arr = np.array([1, 2, 3, 4, 5])
        x = arr.copy()
        arr[0] = 42

        print(arr)
        print(x)

        x = arr.view()
        arr[0] = 42

        print(arr)
        print(x)

    - base : Check if Array Owns its Data
        - Every NumPy array has the attribute base that returns None if the array owns the data. Otherwise, the base  attribute refers to the original object.
        - e.g. 
            arr = np.array([1, 2, 3, 4, 5])
            x = arr.copy()
            y = arr.view()

            print(x.base)   # none
            print(y.base)   # arr

8. shape : It returns a tuple with each index having the number of corresponding elements.
    reshape : It changes the shape of an array.

    - e.g. arr = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])
            print(arr.shape)
            newarr = arr.reshape(4, 3)

            print(arr.reshape(2, 4).base)   # it returns the original array, so it is a view.

    - Unknown Dimension : You are allowed to have one "unknown" dimension. Meaning that you do not have to specify an exact number for one of the dimensions in the reshape method.
    - Pass -1 as the value, and NumPy will calculate this number for you.
    - Flattening array means converting a multidimensional array into a 1D array. Use reshape(-1) to do this.

    - Note: There are a lot of functions for changing the shapes of arrays in numpy flatten, ravel and also for rearranging the elements rot90, flip, fliplr, flipud etc. These fall under Intermediate to Advanced section of numpy.

9. Itereating : 
    - For 3-D array code is like this 
        arr = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])

        for x in arr:
        for y in x:
            for z in y:
            print(z)
    
    - nditer() : Or we can use this functions
        for x in np.nditer(arr):
        print(x) 

    - Iterating Array With Different Data Types : We can use op_dtypes argument and pass it the expected datatype to change the datatype of elements while iterating.
    - NumPy does not change the data type of the element in-place (where the element is in array) so it needs some other space to perform this action, that extra space is called buffer, and in order to enable it in nditer() we pass flags=['buffered'].
    - for x in np.nditer(arr, flags=['buffered'], op_dtypes=['S']):
        print(x)

    - Iterating With Different Step Size : 
        for x in np.nditer(arr[:, ::2]):
        print(x)

    - ndenumerate() : Enumeration means mentioning sequence number of somethings one by one. Sometimes we require corresponding index of the element while iterating, the ndenumerate() method can be used for those usecases.
        arr = np.array([1, 2, 3])
        for idx, x in np.ndenumerate(arr):
        print(idx, x)

        output: (0,) 1
                (1,) 2
                (2,) 3

10. Array Join : concatenate() and stack(), hstack(), vstack(), dstack()
    - Joining means putting contents of two or more arrays in a single array.
    - In SQL we join tables based on a key, whereas in NumPy we join arrays by axes.
    - We pass a sequence of arrays that we want to join to the concatenate() function, along with the axis. If axis is not explicitly passed, it is taken as 0.
    - e.g.
        arr1 = np.array([1, 2, 3])
        arr2 = np.array([4, 5, 6])
        arr = np.concatenate((arr1, arr2))
    
    - e,g, Join two 2-D arrays along rows (axis=1):
        arr1 = np.array([[1, 2], [3, 4]])
        arr2 = np.array([[5, 6], [7, 8]])
        arr = np.concatenate((arr1, arr2), axis=1)
        print(arr)

        # output : 
        [[1 2 5 6]
        [3 4 7 8]]

    - stack() : 
        - Stacking is same as concatenation, the only difference is that stacking is done along a new axis
        - We can concatenate two 1-D arrays along the second axis which would result in putting them one over the other, ie. stacking.
        - We pass a sequence of arrays that we want to join to the stack() method along with the axis. If axis is not explicitly passed it is taken as 0.
        - e.g. 
            arr1 = np.array([1, 2, 3])
            arr2 = np.array([4, 5, 6])
            arr = np.stack((arr1, arr2), axis=1)
            print(arr)

            # output : 
            [[1 4]
            [2 5]
            [3 6]]

    - hstack() : NumPy provides a helper function: hstack() to stack along rows.
        - arr1 = np.array([1, 2, 3])
            arr2 = np.array([4, 5, 6])
            arr = np.hstack((arr1, arr2))
            print(arr)

            # output :
            [1 2 3 4 5 6]

    - vstack() : NumPy provides a helper function: vstack()  to stack along columns.
        - arr1 = np.array([1, 2, 3])
            arr2 = np.array([4, 5, 6])
            arr = np.vstack((arr1, arr2))
            print(arr)

            # output :
            [[1 2 3]
            [4 5 6]]

    - dstack() : NumPy provides a helper function: dstack() to stack along height, which is the same as depth.
        - arr1 = np.array([1, 2, 3])
            arr2 = np.array([4, 5, 6])
            arr = np.dstack((arr1, arr2))
            print(arr)

            # output :
            [[[1 4]
            [2 5]
            [3 6]]]

11. Splitting Array : array_split(), 
    - e.g.
        arr = np.array([1, 2, 3, 4, 5, 6])
        newarr = np.array_split(arr, 3)
        print(newarr)

        # output : 
        [array([1, 2]), array([3, 4]), array([5, 6])]
    
    - If the array has less elements than required, it will adjust from the end accordingly.
        arr = np.array([1, 2, 3, 4, 5, 6])
        newarr = np.array_split(arr, 4)
        # output : 
        [array([1, 2]), array([3, 4]), array([5]), array([6])]
    
    - Note: We also have the method split() available but it will not adjust the elements when elements are less in source array for splitting like in example above, array_split() worked properly but split() would fail.

    - It can be used to split 2D and more dimensional array
    - newarr = np.array_split(arr, 3, axis=1)   # Split the 2-D array into three 2-D arrays along rows.
    - An alternate solution is using hsplit() opposite of hstack()
    - Similar alternates to vstack() and dstack() are available as vsplit() and dsplit()

12. where() : to search an array for a certain value, and return the indexes that get a match.
    - e.g. arr = np.array([1, 2, 3, 4, 5, 4, 4])
            x = np.where(arr == 4)      # location of all '4' elements
            x = np.where(arr%2 == 0)    # indexes where the values are even
            print(x)

            # output : 
            (array([3, 5, 6]),)     
    
    - searchsorted() : 
        - There is a method called searchsorted() which performs a binary search in the array, and returns the index where the specified value would be inserted to maintain the search order.
        - The searchsorted() method is assumed to be used on sorted arrays.
        - e.g. arr = np.array([6, 7, 8, 9])
                x = np.searchsorted(arr, 7)
        
        - Search From the Right Side : By default the left most index is returned, use side='right' to return the right most index instead 
        - e.g. x = np.searchsorted(arr, 7, side='right')

        - Multiple values : x = np.searchsorted(arr, [2, 4, 6])

13. sort() : 
    - print(np.sort(arr))       # it return copy, and leaves original value as it is
    - You can also sort arrays of strings, or any other data type:

14. Filtering Arrays : 
    - Getting some elements out of an existing array and creating a new array out of them is called filtering.
    - In NumPy, you filter an array using a boolean index list.
    - A boolean index list is a list of booleans corresponding to indexes in the array.
    - If the value at an index is True that element is contained in the filtered array, if the value at that index is False that element is excluded from the filtered array.
    - e.g. arr = np.array([41, 42, 43, 44])
        x = [True, False, True, False]
        newarr = arr[x]
        print(newarr)

        # output : 
        [41 43]

    - You can also create boolean index list using loops or conditions

15. Random Numbers in NumPy : 
    - 